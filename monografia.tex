
\documentclass[a4paper, 12pt, twoside]{book}

%% Escrevendo em portugues:
\usepackage[brazil]{babel}	
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage[scaled]{helvet}
\usepackage[utf8]{inputenc}
\usepackage{upquote} %fix minted quotes
\usepackage{parskip} %fix paragraph spacing inside tubainabox
\usepackage{setspace}
\usepackage{monografia}
\usepackage[colorlinks=true]{hyperref}
\usepackage{verbatim}
\usepackage[a4paper, top=46mm, left=29mm, right=29mm, bottom=32mm, includefoot]{geometry}
\usepackage{array}
\usepackage{rotating}


\usepackage[pdftex]{graphicx}           % usamos arquivos pdf/png como figuras

\usepackage{fancyhdr}

\raggedbottom

\newcommand{\codechunk}[1]{{\ttfamily {\small #1}}}


\input{pygments.tex}

\begin{document}

\begin{titlepage}
\vspace*{\fill}
\vspace{-5cm}
\center{\begin{spacing}{1.0}\huge \textbf{MetricMiner: uma ferramenta web de apoio à mineração de repositórios de software}\end{spacing}}
\vspace{2cm}
\center\textsc{{\Large Francisco Sokol}}
\vspace{1cm}
\center\textsc{{\large Orientador: Marco Aurélio Gerosa}}
\center\textsc{{\large Co-orientador: Mauricio Finavaro Aniche}}
\vfill
\end{titlepage}

% \title{MetricMiner: uma ferramenta web de apoio à mineração de repositórios de software}
% \author{Francisco Sokol}
% \maketitle

\pagestyle{plain}

\pagenumbering{arabic}
\setcounter{page}{1}

\tableofcontents

\newpage

\chapter{Introdução}

    Evolução de Software é uma área da Engenharia de Software que estuda as atividades de desenvolvimento de um sistema de software após a sua concepção inicial e implantação em produção. De acordo com \cite{DBLP:series/springer/Mens08}, esse termo foi usado pela primeira vez em um trabalho publicado por Manny Lehman. Neste trabalho, o autor enuncia as ``leis da evolução de software'', defendendo que programas que representam alguma atividade do mundo real evoluem continuamente, caso contrário, se tornam menos úteis e perdem seu valor \cite{Lehman1980b}. Além disso, Lehman afirma que esse processo de mudança contínua faz com que a complexidade do software cresça inevitavelmente, tornando sua estrutura
    cada vez mais pobre e seu custo de manutenção maior.
    
    Considerando ainda diversos trabalhos indicando que o custo de manutenção de um software 
    ultrapassa 50\% do custo total de um projeto, observa-se que encontrar meios de se
    manter a qualidade interna de um software é importante. Por meio do desenvolvimento de
    ferramentas e métodos, a evolução de software busca entender e controlar esse processo
    para o tornar mais eficiente.
    
    Nesse contexto, a Mineração de Repositórios de Software estuda o processo de evolução de forma empírica, por meio da análise dos artefatos envolvidos no seu desenvolvimento como código fonte, dados do sistema de controle de versão e sistemas de rastreamento de bugs \cite{Kagdi:2007}. Por meio da mineração desses dados, são extraídas diversas informações úteis ao desenvolvimento de um software, como, por exemplo, a indentificação de classes que são modificadas constantemente, classes mais propensas a falhas, entre outras. Com essas informações, equipes de desenvolvimento podem tomar ações para aprimorar o processo de desenvolvimento do sistema.

    \section{Motivação}
        Para desenvolver um trabalho em mineração de repositórios, o pesquisador é obrigado 
        a carregar diversos projetos em sua estação de trabalho e realizar uma série de cálculos
        sobre o código dos projetos e sobre os metadados de seu repositório. Esse processo 
        requer a instalação de diversas ferramentas e bibliotecas localmente para reaproveitar
        as ferramentas desenvolvidas nessa área, tornando o processo trabalhoso e demorado.

        Além de ser um processo complexo, esse tipo de pesquisa consome muitos 
        recursos computacionais. Baixar os repositórios a serem minerados consome um volume
        considerável de banda. Depois, os dados devem ser processados e persistidos em um 
        banco de dados, ocupando um grande volume de disco. Só então o pesquisador pode 
        calcular métricas sobre esses dados, além de extrair relações entre os metadados do 
        histórico do sistema de controle de versão, gastando uma quantidade grande de
        processamento de CPU. Só depois de passar por todas essas etapas, é possível extrair
        dados e avaliar hipóteses por meio de análises estatísticas.

        Dessas dificuldades surgiu a motivação para o desenvolvimento do MetricMiner,
        uma aplicação web que realiza todas as etapas da mineração de um repositório de 
        software. Essa ferramenta disponibiliza um grande volume de dados já processados 
        prontos para serem extraídos e analisados pelo pesquisador, poupando tempo e recursos 
        computacionais.
    
    \section{Estrutura da monografia}
        Este trabalho está estruturado da seguinte forma: 
        \begin{itemize}
            \item Capítulo \ref{ch:conceitos}: são abordados temas 
                envolvidos no desenvolvimento desse trabalho, em um breve levantamento bibliográfico.
            \item Capítulo \ref{ch:arquitetura}: apresenta a arquitetura e as tecnologias
            envolvidas no desenvolvimento do MetricMiner.
            \item Capítulo \ref{ch:avaliacao}: expõe os resultados obtidos com a ferramenta 
                na mineração de repositórios de projetos de código aberto.
            \item Capítulo \ref{ch:conclusao}: apresenta uma análise dos resultados e levantamento 
                de possíveis extensões futuras do trabalho.
            \item Capítulo \ref{ch:subjetiva}: apresenta as impressões do aluno na realização 
                deste trabalho e a sua relação com o curso de Bacharelado em Ciência da Computação.
        \end{itemize}
    
\chapter{Mineração de Repositórios de Software} \label{ch:conceitos}
    Esta seção é uma introdução aos principais temas de pesquisa envolvidos no desenvolvimento
    deste trabalho. As Seções \ref{sc:evolucao} e \ref{sc:mineracao} contém, respectivamente, 
    uma introdução a Evolução de Software e Mineração de Repositórios de Software, as duas áreas 
    da Engenharia de Software envolvidas no desenvolvimento deste trabalho. Na Seção 
    \ref{sc:metricas}, são apresentadas algumas métricas de código fonte implementadas no 
    MetricMiner. 

    \section{Evolução de software} \label{sc:evolucao}
        No final da década de sessenta, o termo ``manutenção de software'' foi definido 
        como qualquer atividade de desenvolvimento realizada sobre o software após a sua
        entrega e implantação inicial. Esta também era a visão estabelecida no modelo de
        desenvolvimento de software em cascata, proposto por Royce, em 1970 
        \cite{DBLP:series/springer/Mens08}. Nesse modelo, a manutenção do sistema era a fase final do 
        desenvolvimento, em que eram feitos apenas pequenos ajustes e correção de erros.
        
        Com o passar do tempo, percebeu-se que esse processo era pouco eficiente, 
        principalmente porque os requisitos levantados apenas na fase inicial do projeto se 
        modificavam frequentemente, mesmo durante a fase de manutenção. Na tentativa de compreender
        a natureza dessas mudanças no processo de desenvolvimento, Manny Lehman realizou diversos 
        estudos empíricos sobre o desenvolvimento de sistemas da IBM \cite{Lehman2,Lehman1980b,Lehman1985}.
        
        No trabalho publicado em 1980 \cite{Lehman1980b}, Lehman define três classes de programas.
        A classe S contém programas cujas funcionalidades podem ser especificadas formalmente e possuem uma 
        solução precisa. Problemas famosos como o do caixeiro viajante, n-rainhas, fluxo máximo, entre outros,
        são exemplos que podem servir de especificação para um programa da classe S. Esse 
        tipo de programa é estático (a letra S vem de \textit{static}), pois uma vez estabelecida a 
        solução para seu problema, esta satisfaz seus requisitos por completo.
        
        A classe P contém programas criados para solucionar algum problema do mundo real, que também   
        é especificável formalmente, porém não pode ser solucionado com precisão absoluta (a letra P 
        vem de \textit{real world \textbf{p}roblem solution}). Exemplos
        dessa classe incluem programas para previsão do tempo, um jogador de xadrez, um 
        escalonador de vôos e linhas de trem, entre outros. Os resultados obtidos por programas dessa
        classe não são soluções exatas do problema, devido à complexidade ou à própria natureza deste.
        Programas da classe P, portanto, também possuem seus requisitos especificados com precisão e 
        as mudanças realizadas sobre eles acontecem apenas com o objetivo de aprimorar sua performance ou a qualidade dos resultados.
        
        Os programas da classe E são aqueles cuja especificação não pode ser definida completamente.
        Tais programas são inseridos no mundo real para agilizar tarefas de seu domínio, modificando 
        a forma como as atividades são realizadas. Exemplos de programas da classe E são: sistemas 
        operacionais, sistemas de controle aéreo, de mercado financeiro, entre outros. Programas 
        dessa classe modificam o seu domínio de aplicação após sua implantação inicial, então é 
        natural que com o passar do tempo requisitos sejam levantados para satisfazer 
        novas necessidades da atividade que foi alterada. Programas dessa classe estão
        sujeitos a sofrerem alterações constantes após a implantação inicial e, portanto, estão
        em um processo de evolução constante (a letra E vem de \textit{evolution}).
        
        Assim, sistemas da classe E estão mais sujeitos a mudanças do que programas das classes S 
        e P. Por isso, Lehman dirigiu seu trabalho sobre a análise da evolução de programas da 
        classe E. Em uma tentativa de descrever esse processo de evolução \cite{Lehman1980b}, o 
        autor propõe as \textit{leis da evolução de software}:
        \begin{itemize}
            \item Mudança contínua: Um programa da classe E muda continuamente, caso contrário, se 
                   torna menos útil gradativamente.
            \item Complexidade crescente: Com o processo de mudança contínua, a complexidade do 
                  software cresce, a menos que sejam dirigidos esforços para reduzir ou manter essa 
                  complexidade.
            \item Auto regulação: A evolução de software é um processo auto regulado pelo \textit{feedback} 
                  das mudanças feitas no sistema e as reações a essas mudanças no domínio em que ele 
                  é utilizado.
            \item Conservação de estabilidade organizacional: A taxa com que as modificações são 
                  feitas sobre o software ao longo de seu ciclo de vida é estatisticamente invariante.
            \item Conservação de familiaridade: A evolução de um programa é limitada pela 
                  familiaridade que seus desenvoldores tem com o sistema.
        \end{itemize}

        O trabalho de Lehman foi o primeiro a utilizar o termo ``evolução de software'' para
        descrever o processo de mudança sobre sistemas de software. Hoje, essa área de pesquisa
        envolve diversos temas, como: engenharia reversa e reengenharia, qualidade de software,
        gerenciamento de configuração de software, estimativas de custos, entre outros 
        \cite{DBLP:series/springer/Mens08}.
        
        Ainda não há um consenso da validade dessas leis para sistemas de software de código aberto. 
        Em  \cite{DBLP:series/springer/Fernandez-RamilLWC08}, os autores discutem a validade dessas
        leis analisando diversos estudos realizados sobre projetos de código aberto, concluindo que
        algumas das leis se aplicam, enquanto ainda não há evidências científicas de validade da 
        maioria delas.
        
    \section{Mineração de repositórios de software} \label{sc:mineracao}
        Compreender o processo de evolução de um software é uma tarefa complexa. Sistemas de software grandes possuem um longo histórico de desenvolvimento com diversos desenvolvedores trabalhando em diferentes partes do sistema. É comum que nenhum desenvolvedor conheça o código do sistema por completo por conta da sua complexidade ou mesmo porque os integrantes que iniciaram o desenvolvimento do projeto já não fazem mais parte da equipe. Portanto, analisar os dados históricos do desenvolvimento de um software grande manualmente é inviável. 

        Assim, a Mineração de Repositórios de Software analisa a evolução de software de forma automatizada aplicando técnicas da Mineração de Dados sobre o histórico do desenvolvimento de sistemas de software \cite{workshop-gustavo-aniche}. Os estudos desenvolvidos nessa área revelam informações úteis ao desenvolvimento de um projeto em particular ou ainda encontram padrões na evolução de software que podem ser generalizáveis para outros sistemas.

        O termo ``repositório de software'' abrange todos os artefatos produzidos durante o 
        desenvolvimento de um sistema de software, desde os arquivos com o código fonte do sistema que 
        podem estar armazenados em um sistema de controle de versão, até mensagens em listas de
        emails trocadas entre os desenvolvedores. Tais repositórios contêm informações valiosas, 
        que podem ser exploradas para compreender a evolução de software e contribuir com o 
        desenvolvimento do projeto.

        Em \cite{DBLP:series/springer/DAmbrosGLP08}, os autores destacam os seguintes tópicos 
        estudados na análise de repositórios de software:
        \begin{itemize}
            \item \textbf{Concentração do trabalho dos desenvolvedores e análise de redes sociais}. 
            O objetivo nesse tópico é descobrir quanto e em quais pontos do software os desenvolvedores estão dedicando mais seus esforços e como eles se comunicam, para buscar soluções de problemas no processo de desenvolvimento e na estrutura da equipe.
            \item \textbf{Impacto e propagação de alterações}. 
            Busca ententer o efeito das mudanças feitas em
            certa parte do sistema sobre o resto do código do projeto. Compreendendo melhor o efeito
            dessas alterações, a equipe estima melhor os custos das tarefas. Além disso,
            um desenvolvedor pode ser informado de quais arquivos ele precisará checar após ter feito
            uma certa alteração.
            \item \textbf{Análise de tendências e \textit{hotspots}}. 
            \textit{Hotspots} são pontos do software
            que sofrem alterações frequentemente. Encontrar tais pontos do sistema, ajuda a 
            levantar deficiências na arquitetura do projeto e sugerir possíveis refotatorações para
            aprimorar sua manutenabilidade.
            \item \textbf{Previsão de falhas e defeitos}.
            Os dados disponíveis em repositórios de software
            podem ser usados como entrada para algoritmos de aprendizagem de máquina, para criar
            modelos preditivos de possíveis falhas no sistema. Com esse modelo, a equipe
            toma ações preventivas para previnir falhas em versões futuras.
        \end{itemize}

        Nesse trabalho, os autores também descrevem um modelo de dados para armazenar informações do
        sistema de controle de versão e de um sistema de rastreamento de bugs de um certo software.
        Esse modelo guarda os dados de cada \textit{commit} do projeto, como arquivos modificados, linha adicionadas/removidas, mensagem do autor e associa essas informações a bug extraído 
        do sistema de rastreamento de bugs. Para popular esse modelo, é utilizado arquivo de log
        do sistema de controle de versão \textit{CVS} e o sistema de rastreamento de bugs 
        \textit{Bugzilla}. Os autores denominaram esse modelo de dados \textit{Release History 
        Database} (RHDB). Com os dados desse modelo, foram desenvolvidas três ferramentas para 
        vizualização das informações extraídas.

        Em \cite{Kagdi:2007}, é apresentada uma avaliação de diversos trabalhos de Mineração
        de Repositórios de Software (MRS). A partir da análise desses trabalhos, os autores propõem
        uma taxonomia para classificar os estudos nessa área. Essa classificação se baseia
        em quatro aspectos dos estudos avaliados: a fonte de informação dos dados, os objetivos
        do trabalho, a metodologia adotada para analisar os dados e a granularidade dos dados
        analisados.

        Em relação às fontes de informação, três categorias foram levantadas: as versões do software 
        e de seus artefatos, as diferenças entre esses artefatos e os metadados de cada mudança
        feita sobre o software. As versões e alterações do software são coletadas de Sistemas
        de Controle de Versão (SCV). Os metadados dessas alterações, como autor, data e comentário do 
        autor também podem ser extraídas do SCV e complementadas com dados de um sistema de 
        rastreamento de bugs e mensagens trocadas pelos desenvolvedores em listas de email.

        Quanto aos objetivos dos estudos em MRS, os autores classificam os trabalhos analisados
        em relação às questões de pesquisa que dirigem esses estudos. Foram definidas duas classes
        de questão de pesquisa. A primeira é composta por questões do tipo \textit{market-basket}
        (termo emprestado da mineração de dados). São estudos que buscam avaliar a relação
        entre certos eventos e dados da evolução de software. Questões de pesquisa como ``se um evento A
        acontece quais outros eventos decorrem de A?'' se enquadram nesse conjunto. A segunda classe
        é composta por questões de predomínio (\textit{prevalence question}). Questões como ``quantas
        vezes um determinado módulo foi modificado?'' ou ``quais classes foram reutilizadas no sistema?''
        são exemplos de questões dessa classe.

        Dois métodos principais foram encontrados nos estudos avaliados. O primeiro é o estudo
        de mudanças sobre propriedades do software (\textit{changes to properties}), que é a 
        análise de propriedades de alto nível dos sistemas, como métricas de complexidade ou
        manutenabilidade, por exemplo. Na segunda estratégia de estudo, são analisadas 
        as alterações diretamente nos artefatos, em um nível mais baixo 
        (\textit{changes to artifacts}).

    \section{Métricas de código-fonte} \label{sc:metricas}

    Métricas são medidas numéricas de propriedades do código de um programa. Por meio delas, é possível medir e comparar numericamente propriedades abstratas como, por exemplo, acoplamento e coesão das classes de um sistema. Tais métricas são utilizadas no contexto da Mineração de Repositórios para mensurar propriedades de um sistema analisado. A seguir, as principais métricas implementadas no MetricMiner (os detalhes da implementação são discutidos na Seção \ref{sc:arquitetura}):

    \begin{itemize} 
        \item \textbf{Complexidade Ciclomática:} mede a complexidade do código, quanto maior o número de instruções como \codechunk{if}, \codechunk{while}, \codechunk{case}, \codechunk{\&\&}, \codechunk{||}, ou o operador ternário \codechunk{?}, mais complexo é o código e, portanto, maior o valor da métrica \cite{maccabe:76}.
        \item \textbf{Falta de Coesão dos Métodos (\textit{LCOM}):} mede a coesão de uma classe, considerando o número de atributos da classe que cada método utiliza (considerando que uma classe é coesa se todos os métodos acessam todos os atributos) \cite{henderson:96}.
        \item \textbf{Acoplamento eferente (\textit{Fan-out}):} mede o acoplamento de uma classe, contando o número de invocações de métodos de outras classes \cite{lorenz:94}.
        \item \textbf{Quantidade de Linhas de Código (\textit{LOC}):} a contagem de linhas por método \cite{chidamber:94}.
        \item \textbf{Quantidade de Invocações de Métodos:} a contagem de invocações por método \cite{li:93} em uma classe.
    \end{itemize}

\chapter{Trabalhos relacionados} \label{ch:trabalhos}

Nesta Seção serão apresentadas ferramentas que se relacionam ao MetricMiner.

\section*{Sonar}
    Não se conhece ferramentas web de suporte a mineração de repositórios de software. Uma ferramenta que se assemelha ao MetricMiner é o Sonar \footnote{http://www.sonarsource.org/}, uma aplicação web que analisa o código fonte e extrai uma variedade de relatórios sobre o sistema, como resultados de métricas de código e dependências estruturais entre as classes. O foco dessa ferramenta é apoiar a equipe de desenvolvimento e acompanhar a qualidade do código escrito. O Sonar não armazena metadados do sistema de controle versão e não possibilita que se extraia dados dos projetos armazenados, mas fornece uma interface de vizualização com muitos recursos. Por esses motivo, o Sonar é muito utilizado na indústria e pouco utilizado para fins acadêmicos.
    
    Diferentemente do Sonar, o MetricMiner tem o foco na área acadêmica, possibilitando que os usuários extraiam dados calculados pelo sistema para realizar a análise que desejar, sem focar tanto na vizualização dos dados armazenados.

\section*{Eclipse Metrics}
    O Eclipse Metrics\footnote{http://metrics.sourceforge.net/} é um \textit{plugin} para o Eclipse que calcula uma variedade de métricas de código no ambiente do desenvolvedor. Dessa forma, para que se acompanhe a evolução do código do projeto é necessário executar manualmente o \textit{plugin} para os \textit{releases} que se deseja analisar. No MetricMiner, o cálculo das métricas é realizado sobre todo o histórico de versões do projeto analisado, sem que o usuário precise selecionar as versões manualmente. Além disso, não é necessário que o usuário configure nada em seu ambiente e nem que mantenha as versões que deseja analisar localmente.
    
\section*{Kalibro e Analizo}
    Desenvolvidos no Brasil, o Kalibro\footnote{\url{http://www.kalibro.org/}} e o Analizo\footnote{\url{http://www.analizo.org/}} são ferramentas que calculam as principais métricas de código fonte. Enquanto o Analizo calcula métricas de código de diversas linguagens, o foco do Kalibro é dar suporte ao desenvolvedor, sugerindo valores de referência para as métricas calculadas, apontando possíveis problemas no projeto analisado. A ferramenta permite que os valores de referência sejam configurados por projeto. Através de código JavaScript, é possível compor as métricas calculadas pelo Analizo, permitindo que o usuário crie novas métricas. Assim como o Eclipse Metrics, o Kalibro não analisa todo o histório de versões, de forma que o usuário precisaria selecionar as versões e recalcular as métricas manualmente.

\section*{Mezuro}
    O Mezuro\footnote{\url{http://mezuro.org/}} é uma aplicação web construída sobre o Kalibro e o Analizo. Por meio de sua interface, o usuário cadastra projetos de software e as métricas implementadas no Analizo são calculadas sobre o código. Valores de referência das métricas são exibidas ao usuário nos resultados calculados, sugerindo pontos positivos e negativos no código do projeto. Atualmente, a aplicação se encontra em fase de desenvolvimento em \url{http://mezuro.org/}

\section*{EvolTrack}
    Desenvolvido Universidade Federal do Rio de Janeiro, o EvolTrack é uma ferramenta de vizualização da evolução de um software. Desenvolvido como um \textit{plugin} para o Eclipse, o EvolTrack processa o histórico do sistema de controle de versão de um projeto e possibilita que o usuário vizualize a evolução das classes do projeto ao longo do tempo. A ferramenta exibe o diagrama de classes da versão do projeto e o usuário avança no tempo vizualizando as classes novas e removidas. Atualmente, a ferramenta suporta apenas o sistema de controle de versão SVN. Utilizando a infraestrutura da plataforma Eclipse, o EvolTrack possui \textit{plugins} para diferentes vizualizações dos dados, como o EvolTrack-SocialNetwork \cite{vahia:11}, que possibilita vizualizar as relações entre os desenvolvedores na evolução de um software.

\section*{ArchView}
    O ArchView \cite{pinzger:05} é uma ferramenta de vizualização para a análise da evolução de um software. A ferramenta extrai informações do sistema de controle de versão (CVS) e do sistema de rastreamento de \textit{bugs} (Bugzilla) e calcula diversas métricas para cada versão do software. Depois de processar os dados, o ArchView possibilita que o usuário vizualize diversas métricas de módulos ou arquivos, de diferentes versões do projeto, exibidas em diagramas de kiviat. Além disso, o software exibe o acoplamento dos diferentes módulos com base no histórico de alterações no repositório de código.

\section*{CodeCity}
    O CodeCity \cite{wettel07} é uma ferramenta de vizualização que utiliza a metáfora de uma cidade para representar o software analisado. A ferramenta constrói uma representação gráfica tri dimensional do projeto analisado, representando cada classe do sistema como um prédio na cidade exibida. As classes são agrupadas em distritos e subdistritos da cidade de acordo com a hierarquia de pacotes do sistema. O número de métodos e de atributos de cada classe são mapeadas na altura e largura, respectivamente, de cada prédio.

\section*{Ostra}
    O Ostra \cite{oceano} é uma aplicação desenvolvida na Universidade Federal Fluminense. Esssa ferramenta utiliza a infraestrutura do Oceano, aplicação desenvolvida em outro projeto do grupo. O Ostra processa todo o histórico de desenvolvimento de um projeto de software a partir do sistema de controle de versão (SVN) e do sistema de controle de construção (Maven). Para cada versão do projeto minerado, o Ostra calcula métricas de código a partir das classes compiladas pelo sistema de controle de construção e armazena os resultados. Após essa etapa, a ferramenta aplica técnicas de mineração de dados para extrair regras de associação dos dados minerados. Além disso, a ferramenta possui uma interface web pela qual o usuário cadastra os projetos e vizualiza gráficos e tabelas com o resultados das métricas mineradas.
    \section{Quadro comparativo}

% explicar o que é git, svn, cvs e as bantagens de processamento de código em texto puro

    A Tabela \ref{tab:relacionados} exibe um quadro comparativo entre as ferramentas descritas anteriormente e o MetricMiner. É importante destacar que o procesamento de código em texto puro (4ª linha da Tabela) é um aspecto de valor das ferramentas analisadas, já que a compilação de projetos grandes pode ser complexa e atrasar o processo de mineração. Para esclarecimento das três últimas linhas da Tabela: Git, SVN e CVS são sistemas de controle de versão muito utilizados no desenvolvimento de sistemas de software.

    \begin{table}[H]\begin{center}
        \begin{tabular}{| p{8cm} | c | c | c | c | c | c | c | c | c |}
            \hline                        
             &  \begin{sideways}\bf MetricMiner\end{sideways} & \begin{sideways}\bf Sonar\end{sideways} & \begin{sideways}\bf Eclipse Metrics\end{sideways} & \begin{sideways}\bf Kalibro e Analizo\end{sideways} & \begin{sideways}\bf Mezuro\end{sideways} & \begin{sideways}\bf Evoltrack\end{sideways} & \begin{sideways}\bf ArchView\end{sideways} & \begin{sideways}\bf CodeCity\end{sideways} & \begin{sideways}\bf Oceano\end{sideways}\\
            \hline
            \textbf{Aplicação web} & X & X & - & - & X & - & - & - & X\\
            \hline
            \textbf{Interface de consulta aos dados minerados} & X & - & - & - & - & - & - & - & -\\
            \hline
            \textbf{Cálculo de métricas de código} & X & X & X & X & X & - & X & - & X\\
            \hline
            \textbf{Processamento de código em texto puro (não compilado)} & X & - & - & X & X & - & - & - & -\\
            \hline
            \textbf{Interface gráfica de vizualização dos dados} & - & - & - & - & - & X & X & X & X\\
            \hline
            \textbf{Processamento de repositórios Git} & X & - & - & - & X & - & - & - & -\\
            \hline
            \textbf{Processamento de repositórios SVN} & X & - & - & - & X & X & - & - & X\\
            \hline
            \textbf{Processamento de repositórios CVS} & - & - & - & - & X & - & X & - & -\\
            \hline
        \end{tabular}
        \caption{Quadro comparativo entre as aplicações relacionadas ao MetricMiner \label{tab:relacionados}}
    \end{center}\end{table}


    
\chapter{MetricMiner} \label{ch:arquitetura}

    O MetricMiner surgiu a partir do rEvolution\footnote{http://github.com/mauricioaniche/rEvolution}, uma ferramenta de linha de comando que extrai dados de um repositório local e persiste em banco de dados  relacional. Boa parte do código do rEvolution pôde ser reutilizada no MetricMiner, como o componente que realiza a interface com o sistema de controle de versão, que é descrito com mais detalhes na Seção \ref{sc:tecnologias}. Todo o código e o histórico de desenvolvimento do MetricMiner se encontra hospedado no github: \url{http://github.com/metricminer/metricminer}.

    As limitações do rEvolution serviram de motivação para o desenvolvimento do MetricMiner. Primeiramente, o rEvolution coleta dados de apenas único projeto, de forma que é necessário executar o programa manualmente para a mineração de sistemas diferentes. Além disso, a configuração para se executar o rEvolution é complexa. É necessário configurar a conexão com o banco de dados, instalar o sistema de controle de versão utilizado pelo projeto a ser minerado e carregar o projeto localmente (o que pode ser demorado dependendo do tamanho do projeto). 

    Assim, decidiu-se que o MetricMiner deveria ser uma aplicação web, poupando o pesquisador de instalar e configurar qualquer ferramenta localmente. Além disso, sendo uma aplicação web, a ferramenta pode aproveitar a escalabilidade da computação em nuvem. Atualmente o MetricMiner está implantando sobre a infraestrutura de computação em nuvem da locaweb. Durante a fase de testes da ferramenta, a capacidade de armazenamento do disco chegou ao seu limite e foi necessário aumentar tal capacidade. Esse aprimoramento foi feito sem que fosse necessário reinstalar o servidor e sem que houvesse qualquer perda dos dados armazenados. O mesmo não seria possível se o MetricMiner não fosse uma aplicação web.

    Nas subçeções seguintes, o MetricMiner é descrito com maiores detalhes. Em \ref{sc:abordagem}, é apresentado o fluxo do processo de mineração realizado pelo MetricMiner e as principais funcionalidades implementadas. Na Seção \ref{sc:tecnologias}, as tecnologias utilizadas para o desenvolvimento do sistema serão descritas brevemente. Em \ref{sc:arquitetura}, são presentados os detalhes da arquitetura da ferramenta.

    
    \section{Principais funcionalidades} \label{sc:abordagem}
        O MetricMiner possui uma interface web, pela qual os usuários cadastram projetos de
        sofware para serem minerados. Para esse cadastro, devem ser fornecidos um nome e a url
        pública para o repositório de código do projeto. Até o momento, os sistemas de controle de versão 
        com suporte são o Git e o SVN.

        Como a maioria das etapas da mineração de dados são demoradas, como
        clonar repositórios, persistir suas informações no banco de dados e calcular métricas sobre o
        código fonte, essas tarefas são executadas de maneira assíncrona, por meio 
        de uma fila de execução armazenada no banco de dados. Cada tarefa é registrada no sistema e 
        processada por um componente que constrói as dependências de cada tarefa e as executa na 
        ordem em que foram cadastradas.

        Portanto, após o cadastro do projeto, são registradas quatro tarefas relativas a esse 
        projeto: carregamento do repositório de código, processamento de todas as versões
        dos arquivos do repositório e armazenamento dos dados,
        remoção dos arquivos carregados e cálculo das métricas de código sobre todos
        as versões do código fonte do projeto.

        Ao final desse processo, todas as informações do repositório do projeto e métricas de código estão persistidas no banco de dados e disponíveis para serem extraídas pelo pesquisador. É importante ressaltar que após a extração dos dados do sistema de controle de versão, é possível implementar novas métricas para serem calculadas sobre o código, sem precisar executar todos os passos anteriores novamente. A Figura \ref{fig:diagrama} descreve as tarefas envolvidas no processo de mineração sobre um repositório de software cadastrado na ferramenta.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=1.0\textwidth]{img/diagrama.png}
            \caption{Diagrama do processo de mineração realizado pelo MetricMiner}
            \label{fig:diagrama}
        \end{figure}

        Cada projeto possui sua própria página no sistema. A Figura \ref{fig:screen_projeto} exibe a 
        tela de vizualização no MetricMiner do projeto Ant, software de código aberto da fundação     
        Apache com mais de doze mil \textit{commits}. Nessa tela, são exibidas informações básicas 
        sobre o projeto como número de \textit{commits}, número de \textit{commiters}, url do 
        repositório e data do primeiro e último \textit{commit}. São exibidos também dois gráficos 
        simples nos quais são vizualizados o número de \textit{commits} nos últimos doze meses 
        (agrupados por mês) e o número de arquivos modificados em cada \textit{commit} nos últimos 
        seis meses (agrupados por \textit{commit}). Também podem ser adicionadas \textit{tags},
        para permitir que projetos de domínios semelhantes sejam agrupados.
    
        \begin{figure}[ht]
            \centering
            \includegraphics[width=1.00\textwidth]{img/ant.png}
            \caption{Tela de vizualização de projeto}
            \label{fig:screen_projeto}
        \end{figure}

        Após o fim do processamento do projeto, o usuário pode realizar consultas aos dados processados pela ferramenta. A Figura \ref{fig:screen_query} exibe a tela na qual é possível inserir uma consulta em SQL ao banco de dados do MetricMiner. Para preservarção da identidade, o nome e email dos autores são anonimizados, de forma que ao consultar o email de um desenvolvedor, por exemplo, é devolvido o resultado de uma função de hash do email desejado. Além disso, não é permitido realizar consultas sobre o código fonte dos projetos. Dessa forma será possível minerar também sistemas de software da indústria, que não são distribuídos sob uma licença de código aberto.

        Depois de salvar a consulta, uma nova tarefa é adicionada à fila de execução e, ao final dessa tarefa, o usuário é informado por email do fim da execução da consulta e pode acessar a página da query para baixar os resultados em um arquivo no formato CSV (\textit{Comma Separated Values}). O usuário também pode acessar as queries criadas por outros usuários e reexecutar tais queries sobre a base de dados. Caso ocorra alguma falha na execução da query (um erro de sintaxe de SQL, por exemplo), a \textit{stacktrace} da falha é armazenada e o usuário pode visulizá-la na página de resultados.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=1.00\textwidth]{img/query.png}
            \caption{Tela de consulta aos dados armazenados}
            \label{fig:screen_query}
        \end{figure}
        \clearpage

    \section{Tecnologias envolvidas} \label{sc:tecnologias}

        Nessa Seção serão descritas brevemente as tecnologias envolvidas no desenvolvimento do MetricMiner.

        \subsection*{VRaptor 3}
            O VRaptor\footnote{\url{http://vraptor.caelum.com.br/}} é um \textit{framework} para desenvolvimento web em java. Este \textit{framework} foca na simplicidade e no padrão de convenção sobre configuração\footnote{\url{http://en.wikipedia.org/wiki/Convention_over_configuration}} para tornar o desenvolvimento mais simples e eficiente. O VRaptor também se baseia fortemente no conceito de injeção de dependências \cite{fowlerdi}. A ideia por trás desse padrão é que as dependências de uma classe são criadas pelo container e não pela aplicação que utiliza tais dependências. O MetricMiner utiliza a injeção de dependências em diversos componentes importantes da arquitetura que são descritos com mais detalhes na seção \ref{sc:arquitetura}

        \subsection*{Hibernate}
            O Hibernate é uma biblioteca de mapeamento objeto-relacional. Utilizando essa biblioteca, é possível mapear classes do sistema a tabelas de um banco de dados relacional de forma transparente para o desenvolvedor. Ou seja, é possível persistir e recuperar os dados sem que seja necessário escrever queries SQL explicitamente. Para reduzir a  quantidade de requisições ao banco de dados, o Hibernate faz cache em memória dos dados que serão persistidos. Em alguns pontos do MetricMiner esse comportamento padrão do Hibernate teve que ser modificado, já que diversas tarefas realizadas no sistema manipulam um volume grande de dados, o que acabou consumindo muita memória na máquina virtual do Java.

        \subsection*{HTML, CSS e JavaScript}
            O MetricMiner é uma aplicação web, portanto a interface com o usuário foi desenvolvida em HTML, CSS e Javascript, que são linguagens interpretadas por um navegador web. HTML (\textit{HyperText Markup Language}) é uma linguagem de marcação, utilizada para estruturar uma página renderizada pelo navegador. CSS (\textit{Cascading Style Sheets}) é uma linguagem declarativa utilizada especificar o layout dos elementos representados em HTML. JavaScript é uma linguagem de script executada pelo navegador após o carregamento da página. Por meio dessa linguagem é possível criar efeitos na página renderizada pelo navegador, criando interfaces mais ricas. Como o foco deste trabalho não é no desenvolvimento da interface, foi utilizado um template de HTML e CSS com o layout básico das páginas do sistema. Para a exibição dos gráficos dos projetos foi utilizada a biblioteca em JavaScript \textit{Google Chart Tools}\footnote{https://developers.google.com/chart/}.



    \section{Decisões arquiteturais} \label{sc:arquitetura}

    O MetricMiner é um sistema em Java, que pode ser implantado em qualquer container web Java. Atualmente, a aplicação está em produção, implantada em um servidor web \textit{Apache Tomcat}\footnote{\url{http://tomcat.apache.org/}}. O MetricMiner utiliza o sistema gerenciador de banco de dados MySQL para armazenar os dados minerados. O sistema executa as tarefas assíncronamente por meio de um fila de execução representada no banco de dados. Nas seções a seguir, são descritos os detalhes dessa arquitetura.

        \subsection*{Modelo de dados}
            O diagrama da Figura \ref{fig:uml_modelo} exibe as principais classes do modelo de dados minerados pelo MetricMiner. As classes e relacionamentos representados nesse diagrama são mapeados em tabelas no banco de dados por meio do Hibernate. 

                \begin{figure}[ht]
                    \centering
                    \includegraphics[width=1.00\textwidth]{img/uml-modelo.png}
                    \caption{Classes do modelo de dados}
                    \label{fig:uml_modelo}
                \end{figure}

            Com esse modelo, todo o histórico do sistema de controle de versão de um projeto fica armazenado no sistema. Cada \textit{commit} está relacionado ao conjunto de modificações realizadas nesse \textit{commit}. Uma modificação pode ser de três tipos: modificação comum, adição ou remoção. Adição ou remoção representam que o artefato foi adicionado ou removido do versionamento. Se o artefato não for binário, a modificação fica associada ao texto desse artefato (armazenado na classe \codechunk{SourceCode}). Dessa forma, todos as versões de cada arquivo de código do projeto ficam armazenados na base de dados. Cada versão dos arquivos de código fica associada ao resultado da execução de diferentes métricas. Para simplificar o diagrama, foram representadas apenas as classes \codechunk{CCResult}, \codechunk{LCOMResult} e \codechunk{LinesOfCodeResult} que armazenam os resultados das métricas de código complexidade ciclomática, LCOM e número de linhas de código, respectivamente. Existem outras quatro classes que armazenam resultados de outras métricas.

        \subsection*{Fila de execução} %% TaskRunner, RunnableTask, RunnableTaskFactory,
            Existem diferentes tipos de tarefas que são executadas no MetricMiner, por exemplo, clonar um repositório de código, processar informações do sistema de controle de versão, entre outras. Para cada tipo de tarefa, existem duas classes associadas que implementam duas interfaces. A primeira é a \codechunk{RunnableTask}, essa interface define apenas um método, \codechunk{run}, que deve executar o trabalho dessa tarefa. A segunda é a \codechunk{RunnableTaskFactory} onde está definido o método \codechunk{build}, que devolve uma instância de uma \codechunk{RunnableTask} para ser executada sobre um projeto específico. Essa é uma aplicação do padrão de projeto \codechunk{Abstract Factory} \cite{gof} e permitiu desacoplar os objetos que executam o trabalho da tarefa da construção desses objetos. O diagrama na Figura \ref{fig:uml_runner} exibe as classes que representam as principais tarefas executadas no MetricMiner.

            \begin{figure}[ht]
                \centering
                \includegraphics[width=1.00\textwidth]{img/uml-runner.png}
                \caption{Diagrama das classes que executam as tarefas do MetricMiner}
                \label{fig:uml_runner}
            \end{figure}

            Para inserir uma tarefa na fila, suas informações são inseridas no banco de dados, incluindo o nome completo (\textit{Fully qualified name}) da classe que implementa \codechunk{RunnableTaskFactory} dessa tarefa em particular. Depois, o método \codechunk{execute} da classe \codechunk{TaskRunner} extrai essas informações e constrói uma instância da factory dessa tarefa por meio da 
            \textit{Reflection API}\footnote{\url{http://docs.oracle.com/javase/tutorial/reflect/index.html}} do Java. Finalmente, uma intância de \codechunk{RunnableTask} é construída e executada. Esse método é executado a cada dez segundos e caso nenhuma tarefa esteja sendo executada, ela realiza o processo descrito anteriormente. Para a implementação da classe \codechunk{TaskRunner}, foi utilizado o plugin vraptor-tasks\footnote{\url{https://github.com/wpivotto/vraptor-tasks}}, que utiliza o Quarts, um famoso \textit{framework} para escalonamento de tarefas.

            Dessa forma, desenvolver novas tarefas é simples, basta criar duas classes implementando as interfaces descritas anteriormente e tal tarefa já poderá ser inserida na fila de execução do MetricMiner por meio do banco de dados.

        \subsection*{Cálculo das métricas de código} %% Metric, MetricFactory, CalculateAllMetricsTask (template method), CalculateMetricTask

            De forma semelhante à arquitetura das tarefas da fila execução, também foi utilizado o padrão \codechunk{Abstract Factory} no design das métricas de código implementadas no MetricMiner. Assim, para cada métrica, existem duas classes implementando duas interfaces: \codechunk{Metric} e \codechunk{MetricFactory}. A interface \codechunk{MetricFactory} define apenas um método, \codechunk{build}, que devolve uma instância da métrica. A interface \codechunk{Metric} define dois métodos principais: 

            \begin{itemize}
                \item \codechunk{void calculate(InputStream input)}: calcula a métrica para o código forncecido lido por meio da classe \codechunk{InputStream}.
                \item \codechunk{Collection<MetricResult> results()}: devolve uma coleção de objetos que representam os resultados dessa métrica que serão armazenados no banco de dados.
            \end{itemize}

            O diagrama UML da figura \ref{fig:uml_metric}, descreve as classes de duas métricas implementadas, a Complexidade Ciclomática e a LCOM.

            \begin{figure}[ht]
                \centering
                \includegraphics[width=0.7\textwidth]{img/uml_metric.png}
                \caption{Diagrama de duas métricas de código implementadas no MetricMiner}
                \label{fig:uml_metric}
            \end{figure}

            As métricas presentes no MetricMiner já haviam sido implementadas pelo grupo de pesquisa (disponível em \url{https://github.com/mauricioaniche/msr-asserts}). A implementação dessas métricas de código utiliza a biblioteca javaparser\footnote{\url{http://code.google.com/p/javaparser/}}. Com essa biblioteca, a árvore sintática abstrata de uma classe java é construída e visitada contabilizando os resultados de cada métrica. Para fazer a análise sintática da classe java, o javaparser utiliza o javacc (java compiler compiler\footnote{\url{http://javacc.java.net/}}) que é uma ferramenta geradora de código que permite construir analisadores sintáticos a partir de uma gramática definida na sintaxe do javacc.

            Para encontrar as classes que implementam as métricas no \textit{classpath} do MetricMiner, foi utilizado o recurso de \textit{Annotations}\footnote{\url{http://docs.oracle.com/javase/tutorial/java/javaOO/annotations.html}} do Java. Todas as classes que implementam métricas são anotadas com a anotação \codechunk{@MetricComponent}. Na inicialização do sistema, a classe \codechunk{MetricMinerConfigs} encontra todas as classes anotadas e as adiciona a lista de métricas registradas.

            Para executar tais métricas, a classe \codechunk{CalculateAllMetricsTask} é executada na fila de execução. Essa tarefa recebe as métricas registradas, percorre todas as versões de código de um determinado projeto cadastrado calculando todas as métricas e persistindo os resultados. De forma semelhante, a tarefa \codechunk{CalculateMetricTask} cálcula uma métrica específica para todas as versões de um projeto. 

            % falar tb da parte de SCM, como funciona a interface SCM. explicar os métodos da interface e como  
            % fazer para suportar novos.
            % fala do MVC tb. como o vraptor implementa MVC, onde ficam os controllers, como funciona uma 
            % requisição.

    \section{Evolução do desempenho do MetricMiner}

        A mineração dos repositórios da Apache Software Foundation (descrita com detalhes na Seção \ref{sc:apache}) foi utilizada para dirigir o desenvolvimento do MetricMiner. Diversas pequenas otimizações foram realizadas ao longo do desenvolvimento e seus resultados foram medidos com a mineração desses repositórios. 

        A Tabela \ref{tab:evolucao} exibe a evolução do desempenho ao longo do densenvolvimento da ferramenta. Para levantar os dados dessa tabela, foi considerada a mineração de 94 projetos em cada versão do MetricMiner, já que nas primeiras versões da ferramenta nem todos os projetos da Apache foram processados. Além disso, foram desconsideradas as tarefas de download de repositório, pois seu desempenho depende quase exclusivamente de fatores externos como a qualidade da conexão com o repositório remoto.



        Dentre essas otimizações podemos destacar as seguintes:
        \begin{itemize}
            \item \textbf{Utilização de \codechunk{StatelessSession} do Hibernate:} A classe utilizada normalmente para se realizar consultas ao banco de dados com o Hibernate é a \codechunk{Session}. Por padrão, uma instância dessa classe armazena em cache as entidades persistidas ou buscadas no banco de dados. Durante os testes, percebeu-se que esse comportamento padrão causava um consumo de memória excessivo. Para contornar esse problema, foi utilizada a classe \codechunk{StatelessSession}, que não realiza cache dos dados.
            \item \textbf{Consulta para buscar códigos fonte no cálculo de métricas:} Inicialmente, para buscar os códigos fonte para calcular as métricas de código na tarefa \codechunk{CalculateAllMetricsTask}, era utilizada uma consulta que envolvia uma operação \codechunk{JOIN} de SQL trazendo o conteúdo dos arquivos do banco de dados. Como a quantidade de resultados era muito grande, foi necessário paginar os resultados dessa consulta, e portanto essa era executada diversas vezes para processar todas as versões dos arquivos dos projetos. Com o aumento do número de entradas armazenadas, esse processo se tornou  lento. Para otimizar essa tarefa, ao invés de realizar diversos \codechunk{JOIN}'s (que é uma operação custosa em bancos de dados relacionais), foi utilizada apenas uma consulta para trazer todos os identificadores dos arquivos de código e só então o conteúdo de fato desses arquivos eram trazidos do banco de dados para calcular as métricas, diretamente pela sua chave primária. Assim, em vez de executar diversas operações \codechunk{JOIN}, é feita apenas uma consulta envolvendo tal operação.

            \item \textbf{Cache de segundo nível:} Além do cache de primeiro nível (descrito brevemente no primeiro item desta lista), o Hibernate possui um segundo cache, o cache de segundo nível. Diferentemente do cache de primeiro nível, que armazena apenas dados manipulados por uma única instância da classe Session, o cache de segundo nível armazena o resultado de consultas realizadas ao banco por todas as sessões abertas. Por padrão, o cache de segundo nível é desabilitado, no MetricMiner foi utilizada a implementação do EHCACHE\footnote{http://ehcache.org/}. A utilização de tal cache poupou o número de requisições ao banco de dados principalmente nos acessos às páginas web servidas pelo MetricMiner.
        \end{itemize}

        \begin{table}\begin{center}
        \begin{tabular}{| p{5cm} | c | c | c | c | c | }
            \hline                        
             & \textbf{07/ago} & \textbf{16/ago} & \textbf{07/out} & \textbf{25/out} \\
            \hline
            \textbf{Tempo de duração médio das tarefas em minutos} & 5.3 & 4.4 & 5.0 & 3.0 \\
            \hline
            \textbf{Tempo médio das dez tarefas mais lentas em minutos} & 58.2 & 40.3 & 44.2 & 35.3 \\
            \hline
            \textbf{Tarefas com erros} & 0 & 0 & 12 & 0 \\
            \hline
        \end{tabular}
        \caption{Evolução do desempenho do processamento dos projetos ao longo do desenvolvimento do MetricMiner \label{tab:evolucao}}
        \end{center}\end{table}

\chapter{Avaliação da ferramenta} \label{ch:avaliacao}
    
    Nesta seção são descritos os resultados obtidos em dois exemplos de uso do MetricMiner. Na Seção \ref{sc:apache} é exibida a avaliação da ferramenta feita com a mineração dos repositórios de código aberto da Apache Software Foundation. Na Seção \ref{sc:estudo-caso}, é descrita a reprodução de um estudo de mineração de software já publicado na literatura, utilizando os dados processados pelo MetricMiner.

    \section{Exemplo de uso 1: mineração do repositório de código da Apache Software Foundation} \label{sc:apache}

        A capacidade da ferramenta desenvolvida foi avaliada por meio da mineração dos projetos de código aberto disponibilizados pela Apache Software Foundation. Os códigos desses projetos podem ser acessados por meio do sistema de controle de versão Git. A lista completa de projetos se encontra em \url{http://git.apache.org/}. No total, foram cadastrados e processados 307 projetos de código aberto.

        Esse conjunto de projetos minerados representa grande variedade em relação ao domínio de aplicação: existem projetos de domínios complexos como o Harmony - uma implementação da máquina virtual java - assim como outros mais simples como Commons Exec - uma biblioteca java para a execução de comandos do sistema operacional. 

        Além disso, os projetos variam bastante em relação ao tamanho de seu histórico, a Tabela \ref{tab:commits} exibe os dez projetos com maior número de commits. Enquanto o projeto Subversion possui mais de 40 mil commits, outros projetos menores como o Savan possui menos de 20 commits em seu histórico de desenvolvimento. Em média, os projetos armazenados possuem 2660 commits. A Tabela \ref{tab:artefatos} exibe os projetos com maior número de artefatos de código (qualquer arquivo não binário armazenado no repositório) processados no MetricMiner. Essas informações foram extraídas por meio da execução de consultas SQL pela interface do MetricMiner\footnote{As duas consultas utilizadas para extrair essas informações podem ser vizualizadas em \url{http://metricminer.org.br/query/3} e \url{http://metricminer.org.br/query/5}. Nessas páginas também é possível baixar os resultados completos das consultas.}.

        \begin{table}\begin{center}
        \begin{tabular}{| p{6cm} | c |}
            \hline                        
            \textbf{Projeto} & \textbf{Total de commits} \\
            \hline                        
            Apache Subversion & 44224 \\
            \hline
            Apache Flex (Incubating) & 30372 \\
            \hline
            Apache HTTP Server & 24038 \\
            \hline
            Apache OFBiz & 19555 \\
            \hline
            Apache Wicket & 16437 \\
            \hline
            Apache Tuscany SCA 2.x & 16216 \\
            \hline
            Apache Axis1 & 18610 \\
            \hline
            Apache Geronimo & 13136 \\
            \hline
            Apache Cocoon & 13132 \\
            \hline
            Apache Ant & 12782 \\
            \hline
        \end{tabular}
        \caption{Dez projetos com maior número de commits processados pelo MetricMiner \label{tab:commits}}
        \end{center}\end{table}

        \begin{table}\begin{center}
        \begin{tabular}{| p{6cm} | c |}
            \hline                        
            \textbf{Projeto} & \textbf{Total de artefatos de código processados} \\
            \hline
            Apache James & 106363 \\
            \hline
            Apache Tuscany SCA 2.x & 50469 \\
            \hline
            Apache Zeta Components & 45957\\
            \hline
            Apache Web Services Commons XMLSchema & 40287 \\
            \hline
            Apache Tuscany SCA 1.x & 32738 \\
            \hline
            Apache Wicket & 32321 \\
            \hline
            Apache Cocoon & 31535 \\
            \hline
            Apache Geronimo & 29158 \\
            \hline
            Apache OpenEJB & 28113 \\
            \hline
            Apache CXF & 26673 \\
            \hline
        \end{tabular}
        \caption{Dez projetos com maior número de artefatos processados pelo MetricMiner \label{tab:artefatos}}
        \end{center}\end{table}

        Ao final do processo de mineração dos repositórios da Apache, o MetricMiner processou e armazenou mais de 800 mil commits de mais 2 mil autores diferentes, mais 1.5 milhões de artefatos e 5 milhões de versões de arquivos de código. Todo esse volume de dados está armazenado em um banco de dados de mais de 180 GB e disponível para consultas por meio da interface web. O processo de mineração, desde o início do download do primeiro projeto até o cálculo das métricas do último, levou no total aproximadamente 90 horas de duração.

    \section{Exemplo de uso 2: expansão de um estudo da literatura} \label{sc:estudo-caso}
        Para mostrar o valor da ferramenta no contexto de pesquisa em Mineração de Repositórios, foi feita a reprodução de um estudo publicado na área. O trabalho publicado em \cite{SoetensQUATIC2010} foi reproduzido e estendido utilizando os dados minerados no MetricMiner por meio de sua interface de consultas ao banco de dados.

        \subsection*{Artigo publicado}

        Neste trabalho, os autores estudaram o efeito de refatorações sobre a complexidade do sistema. Uma refatoração é o processo de modificar o código para melhorar sua estrutura interna, mas sem modificar seu comportamento externo \cite{fowler-refactoring}. Assim, se aplicada corretamente, a refatoração de código aprimora a manutenabilidade do sistema, sem acrescentar ou remover funcionalidades.

        Para estudar o efeito das refatorações, os autores utilizam a métrica de complexidade ciclomática como medida da complexidade total de um sistema, ou seja, consideram que a complexidade do sistema é a soma da complexidade ciclomática de suas classes. O artigo apresenta uma breve análise matemática sobre o efeito de refatorações comuns sobre a complexidade ciclomática de uma classe. As refatorações analisadas foram:

        \begin{itemize}
            \item Subir método (\textit{pull up method})
            \item Extrair método (\textit{extract method})
            \item Colocar método em linha (\textit{inline method})
        \end{itemize}

        O tabalho analisa 776 versões extraídas do sistema de controle de versão do projeto de código aberto PMD\footnote{\url{http://pmd.sourceforge.net/}}. Para fazer essa análise, os autores utilizaram dois \textit{plugins} da IDE Eclipse: o SVNKit, para extrair o código do repositório e o Eclipse Metrics, para calcular a métrica de complexidade ciclomática. Com esses dois plugins instalados, eles desenvolveram um plugin próprio para realizar o processo de carregar a versão do código, calcular as métricas e armazenar os resultados em arquivos XML. Depois disso, os arquivos XML foram processados e as métricas calculadas foram associadas com as mensagens de cada commit.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=1.0\textwidth]{img/cc-soetens.png}
            \caption{Gráfico da complexidade ciclomática do projeto PMD ao longo do tempo publicado em \cite{SoetensQUATIC2010}}
            \label{fig:evolucao-soetens}
        \end{figure}

        O artigo apresenta a evolução da complexidade ciclomática do projeto ao longo das versões analisadas. A Figura \ref{fig:evolucao-soetens} exibe um gráfico mostrando o aumento da complexidade ciclomática com o tempo, o que é uma evidência da segunda lei da evolução de software (complexidade crescente). 

        Os autores classificam os commits em duas categorias, os que contêm ``refatorações documentadas'' e os que não contêm. Uma ``refatoração documentada'' é um commit que possui em sua mensagem palavras como \textit{``refactoring''}, \textit{``refactored''}, \textit{``refactor''}. Com essa classificação, os autores analisam o efeito sobre a métrica de complexidade ciclomática (CC) dos commits de cada categoria. A Tabela \ref{tab:resultados-soetens} exibe os resultados da classificação do conjunto de commits analisado.

        \begin{table}\begin{center}
        \begin{tabular}{| >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3.3cm} | >{\centering\arraybackslash}m{3.3cm} | >{\centering\arraybackslash}m{3.3cm} |}
            \hline                        
             & \textbf{Decrementaram CC} & \textbf{Não alteraram CC} & \textbf{Incrementaram CC} \\
            \hline
            \textbf{Refatorações documentadas} & 14 & 7 & 12 \\
            \hline
            \textbf{Sem refatoração documentada} & 27 & 580 & 136 \\
            \hline
        \end{tabular}
        \caption{Resultados obtidos em \cite{SoetensQUATIC2010} \label{tab:resultados-soetens}}
        \end{center}\end{table}

        Com esses resultados, os autores concluem que as refatorações raramente afetam a complexidade ciclomática do sistema: ``\textit{we discovered that refactoring practices rarely affect the cyclomatic complexity of a program}''. Os autores analisaram cada commit processado e justificaram essa conclusão contra-intuitiva levantando três motivos possíveis:

        \begin{itemize}
            \item Poucas refatorações envolviam remoção de código duplicado.
            \item Em muitos commits, os autores desenvolviam novas funcionalidade junto com a refatoração de certa parte do código, aumentando a complexidade do sistema independentemente da refatoração.
            \item A maioria das refatorações descobertas realizavam apenas pequenas mudanças no código, como movimentação de métodos e variáveis entre as classes e não mudanças mais complexas como extração de classe, substituição de condicionais por polimorfismo, entre outros.
        \end{itemize}


        \subsection*{Reprodução do estudo}
        Para reproduzir o trabalho descrito anteriormente, foi feita uma consulta ao banco de dados do MetricMiner após a mineração dos projetos da Apache. Como o MetricMiner só calcula a complexidade ciclomática sobre classes na linguagem Java, só foram considerados commits que alteraram arquivos de código fonte Java. A seguinte consulta SQL foi realizada no MetricMiner:

        \input{misc/consulta.tex}

        Essa consulta extrai a complexidade ciclomática calculada de todas as classes já alteradas no histórico de todos os projetos (que possuem classes Java) armazenados na base de dados. Junto com a complexidade ciclomática e o nome do arquivo, são extraídas também o nome do projeto, data e mensagem do commit. Os resultados de tal consulta se encontram em \url{http://metricminer.org.br/query/1}. Com esses resultados, foi desenvolvido um pequeno programa auxiliar em Java que utiliza esses dados para contabilizar os efeitos das refatorações sobre a complexidade ciclomática dos projetos. O código desse programa encontra-se em \url{https://github.com/csokol/refactoring-cc}.

        O programa auxiliar agrupa os dados extraídos por projeto, agrupa arquivos modificados em um mesmo commit e percorre todos os commits contabilizando as alterações na complexidade total do projeto. Para verificar se um commit contém ``refatorações documentadas'', foi utilizado Apache Lucene\footnote{\url{http://lucene.apache.org}} para processar a mensagem do autor, separando o texto em \textit{tokens} e fazendo a normalização (processo de extrair caracteres de pontuação do texto) e \textit{stemming} (processo de extrair a raiz morfológica das palavras) dos \textit{tokens} (essas técnicas e conceitos pertencem a área de recuperação de informação e estão fora do escopo deste trabalho). Com esse processamento de texto feito, bastou verificar se a mensagem de commit contém o  \textit{token} ``refactor'' para determinar se tal commit contém refatorações.

        Ao todo foram analisados commits de 256 projetos diferentes. As Figuras \ref{fig:cc-camel}, \ref{fig:cc-ant} e \ref{fig:cc-tomcat} exibem a evolução da complexidade ciclomática dos projetos Camel, Ant e Tomcat, respectivamente. A evolução da complexidade do Apache Camel demonstra um padrão semelhante a evolução do PMD, publicado no trabalho original. A complexidade ciclomática parte de um valor baixo e vai crescendo desde o início do desenvolvimento, sem muitas variações em sua taxa de crescimento. O Ant e o Tomcat apresentam padrões diferentes. 

        \begin{figure}[ht]
            \centering
            \includegraphics[width=20cm, angle=90]{img/graficos/camel.png}
            \caption{Evolução da complexidade do projeto Camel}
            \label{fig:cc-camel}
        \end{figure}

        O desenvolvimento do Ant também se inicia com a complexidade baixa, porém, ao longo de sua evolução há ``saltos'' na complexidade que se devem a grandes adições ou remoções de código do repositório. Por exemplo, em \ref{fig:cc-ant}(\textbf{A}) há um grande aumento na complexidade total que se deve à importação de código de um repositório antigo ao novo repositório do Ant, o que está descrito na mensagem  do autor desse commit: ``\textit{Add in a clone of the main ant source tree so that it can undergo some heavy refactoring}''.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=20cm, angle=90]{img/graficos/ant.png}
            \caption{Evolução da complexidade do projeto Ant}
            \label{fig:cc-ant}
        \end{figure}

        Já o histórico do Tomcat, ao contrário dos outros dois, já se inicia com uma grande complexidade logo em seu primeiro commit. Isso se deve ao fato do Tomcat ser um projeto de código legado, sendo assim, seu primeiro commit é a importação de código do repositório antigo, o que justifica alta complexidade ciclomática inicial.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=20cm, angle=90]{img/graficos/tomcat.png}
            \caption{Evolução da complexidade do projeto Tomcat}
            \label{fig:cc-tomcat}
        \end{figure}

        De maneira geral, os três projetos aumentam sua complexidade ao longo do histórico de desenvolvimento, confirmando a segunda lei de evolução de software, corroborando com o estudo de \cite{SoetensQUATIC2010}. 

        A Tabela \ref{tab:resultados} exibe os resultados das refatorações sobre a complexidade dos projetos. Observa-se que a maioria das refatorações documentadas incrementaram a complexidade ciclomática. No entanto, a proporção dos commits que decrementaram a complexidade é maior entre o conjunto das refatorações documentadas: aproximadamente 23\% das refatorações documentadas reduziram a complexidade ciclomática enquanto apenas 12\% tiveram o mesmo efeito entre os commits normais. Ainda assim, como no estudo reproduzido, não há evidências de que refatorações diminuem a complexidade de um sistema.

        \begin{table}\begin{center}
        \begin{tabular}{| >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3.3cm} | >{\centering\arraybackslash}m{3.3cm} | >{\centering\arraybackslash}m{3.3cm} |}
            \hline                        
             & \textbf{Decrementaram CC} & \textbf{Não alteraram CC} & \textbf{Incrementaram CC} \\
            \hline
            \textbf{Refatorações documentadas} & 1504 & 1603 & 3230 \\
            \hline
            \textbf{Sem refatoração documentada} & 30145 & 99580 & 121239 \\
            \hline
        \end{tabular}
        \caption{Resultados obtidos na reprodução do estudo \label{tab:resultados}}
        \end{center}\end{table}
        
        \subsection*{Conslusão}
        Utilizando o MetricMiner, foi possível reproduzir e estender o estudo original com sucesso. Como o esperado, os resultados obtidos foram semelhantes ao trabalho dos autores do artigo. O processo de análise dos dados com o MetricMiner se mostrou mais simples do que a abordagem utilizada por Soetens e Demeyer, uma vez que os dados dos commits e cálculo das métricas de código já haviam sido realizadas. Além disso, na abordagem original, o processo de mineração foi muito mais custoso, uma vez que o SVNKit necessita se conectar ao repositório remoto para baixar cada versão do projeto e o Eclipse Metrics calcula métricas com o código compilado (portanto, é necessário recompilar o código de cada versão).

        Considerando que o volume de dados analisado com o MetricMiner foi muito maior que o trabalho original, ainda seria possível se aprofundar na investigação das refatorações documentadas dos desenvolvedores. Seria possível analisar os efeitos das refatorações por projeto, pelo tipo de projeto, pelo tamanho, pela experiência do desenvolvedor, entre outros. Ainda seria possível analisar o efeito sobre métricas de acoplamento e coesão (\textit{Fan out} e \textit{LCOM}), que também são propriedades de qualidade de código.

\chapter{Conclusão e trabalhos futuros} \label{ch:conclusao}
    
        A ferramenta desenvolvida nete trabalho tem valor na área de Mineração de Repositórios de Software. Como exibido na Seção \ref{sc:estudo-caso}, o MetricMiner facilita o desenvolvimento de estudos nessa área de pesquisa com as funcionalidades implementadas até o momento e os dados minerados disponíveis.

        Utilizando a ferramenta desenvolvida, foi possível reproduzir um estudo da literatura com informações de diversos repositórios minerados. Com os dados do MetricMiner, não foi necessário carregar os projetos e executar as tarefas custosas de mineração localmente, como seria preciso utilizando as ferramentas atuais. Dessa forma, a reprodução do estudo foi realizada de forma mais eficiente, poupando recursos computacionais. Com esse processo mais eficiente, foi possível analisar um volume de dados maior, valorizando os resultados obtidos.

        Assim, a ferramenta desenvolvida atinge os objetivos da proposta apresentada no início do trabalho. O MetricMiner oferece uma solução para o desenvolvimento de estudos em mineração de repositórios mais eficiente do que as propostas das ferramentas apresentadas no Capítulo \ref{ch:trabalhos} e da solução desenvolvida em \cite{SoetensQUATIC2010}. Além disso, como foi apresentado na Seção \ref{sc:arquitetura}, a ferramenta possui uma arquitetura extensível, possibilitando que novas métricas e tarefas de mineração sejam desenvolvidas no futuro.

        Ainda assim, diversas melhorias ainda podem ser desenvolvidas no MetricMiner no futuro:
        \begin{itemize}
            \item {\bf Paralelizar a execução de tarefas}: as tarefas de mineração executadas são totalmente independentes entre projetos diferentes, portanto, podem ser executadas concorrentemente, seja no mesmo servidor (em múltiplas \textit{threads}) ou até mesmo de forma distribuída em várias máquinas.
            \item {\bf Novas métricas}: outras métricas de código da literatura podem ser implementadas no MetricMiner. Além disso, métricas de código para outras linguagens de programação também podem ser desenvolvidas (no momento a única linguagem com suporte nas métricas atuais é o Java).
            \item {\bf Novas tarefas de mineração}: a mineração de outras fontes de dados como sistemas de \textit{bug tracking} e listas de email podem ser implementadas para enriquecer a base de dados do MetricMiner.
            \item {\bf Usabilidade da interface web}.
        \end{itemize}

% retomar problema inicial e dizer que o metric miner resolve

\chapter{Parte subjetiva} \label{ch:subjetiva}

Neste parte, a experiência obtida na realização do trabalho é relacionada ao curso de graduação no Bacharelado em Ciência da Computação.

    \section{Desafios e frustrações}
    O principal desafio na encontrado foi conciliar o desenvolvimento deste trabalho, disciplinas da graduação e o estágio na Caelum. Foi desgastante estudar e fazer os trabalhos para as matérias do curso,  e ao mesmo manter as atividades do trabalho de conclusão em dia. Nesse sentido, ter começado a trabalhar cedo na implementação do MetricMiner fez com que fosse possível desenvolver uma ferramenta útil e escrever uma monografia interessante. Além disso, a própria escrita da monografia foi desafiante, uma vez que em nenhum momento do curso foi preciso escrever um trabalho neste formato e desta proporção.

    O desenvolvimento da ferramenta também foi desafiante. A própria natureza do funcionamento MetricMiner, de executar tarefas pesadas e longas assíncronamente, tornou o desenvolvimento complicado em alguns momentos pois foi bastante demorado avaliar por completo as funcionalidades implementadas. Nesse ponto, o apoio da Locaweb com o fornecimento de um servidor facilitou bastante os testes.

    Outro desafio no desenvolvimento foi a preocupação constante com a qualidade do código desenvolvido, com a intenção de densenvolver um sistema que pudesse evoluir e ganhar novas funcionalidades no futuro. Preocupação essa que não existe em quase nenhuma disciplina da graduação, uma vez que a maioria dos trabalhos são pontuais e com ``prazo de validade''. Iniciar o projeto a partir do código de um outro sistema foi desafiante, já que em poucas situações o mesmo acontece nas disciplinas do curso. Além disso, o desenvolvimento do MetricMiner envolveu diversas tecnologias que foram estudadas para que pudessem ser aplicadas adequadamente.

    \section{Disciplinas relevantes para o desenvolvimento do trabalho}

    A seguir, a lista das principais disciplinas que contribuíram para este trabalho de conclusão:
    \begin{itemize}
        \item {\bf MAC0122 -- Princípios de Desenvolvimento de Algoritmos}: disciplina essencial para a implementação dos algoritmos envolvidos no desenvolvimento de qualquer sistema.
        \item {\bf MAC0426 -- Sistemas de Bancos de Dados}: esta disciplina foi importante pois estudei conceitos por trás de sistemas de gerenciamento de banco de dados. Além disso, estudei a linguagem de consulta SQL, usada em diversos pontos no desenvolvimento deste trabalho e na análise dos resultados.
        \item {\bf MAC0342 -- Laboratório de Programação Extrema}: primeiro contato com um sistema de maior escala e de código legado em Java. Essa experiência foi importante para encarar o desafio do desenvolvimento de um sistema como o MetricMiner.
        \item {\bf MAC0332 -- Engenharia de Software}: disciplina na qual entrei em contato com Mineração de Repositórios e alguns conceitos de orientação a objetos utilizados no desenvolvimento da ferramenta. Além disso, nessa disciplina foi desenvolvido um projeto que envolvia diversas tecnologias utilizadas nesse trabalho.
    \end{itemize}

    \section{Futuro deste trabalho}
    Na sequência da entrega da versão final deste trabalho, pretendemos aprimorar a reprodução do estudo apresentado na Seção \ref{sc:estudo-caso} e submeter um trabalho ao ESELAW (\textit{Experimental Software Engineering Latin American Workshop}) 2013 apresentado a ferramenta e o trabalho desenvolvido.

    Para seguir trabalhando na área de mineração de repositórios, o próximo passo seria entrar em contato com outros estudos desenvolvidos na área. O desenvolvimento da seção de trabalhos relacionados nesta monografia foi um início, porém, esta é uma área de pesquisa relativamente nova então o primeiro passo seria tomar conhecimento dos trabalhos recentes publicados em conferências dessa área de pesquisa.

    Além disso, pretendo implementar novas funcionalidades no MetricMiner e usá-lo para extrair informações úteis para o desenvolvimento de software na prática. Pretendo utilizá-lo para minerar dados dos sistemas em que trabalho na Caelum e tentar colocar os conceitos estudados nesse trabalho em prática.


%Na segunda parte da monografia espera-se que você relacione a experiência obtida no trabalho com o BCC. Alguns dos itens que você deve cobrir são os seguintes:

%desafios e frustrações encontrados;
%lista das disciplinas cursadas no BCC mais relevantes para o trabalho;
%observações sobre a aplicação de conceitos estudados nas disciplinas do curso;
%se o aluno fosse continuar atuando na área em que realizou o trabalho, que passos tomaria para aprimorar os conhecimentos relevantes para esta atividade?

\bibliographystyle{sbc}
\bibliography{monografia}

\end{document}

